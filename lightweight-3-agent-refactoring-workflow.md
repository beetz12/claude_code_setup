# 軽量3エージェント協調リファクタリングワークフロー

## 概要

このドキュメントは、小規模なリファクタリングタスク（型安全性の改善、コード品質向上など）を効率的に実行するための軽量なマルチエージェントワークフローを記述します。大規模な機能実装ワークフローとは異なり、3つの専門エージェントのみを使用し、短時間で高品質な結果を提供します。

**対象読者**: Claude Codeが参照して、軽量なマルチエージェント協調を実行するためのガイドです。

**適用分野**:
- 型アサーション（`as any`など）の削除
- ESLintルール違反の修正
- 小規模な性能最適化
- コードスタイルの統一
- 技術的負債の解消
- 依存関係の更新に伴う修正

## ワークフローの中核原則

### 1. 最小限のエージェント構成
- **3エージェント体制**: 調査→実装→レビューの必要最小限
- **明確な役割分担**: 各エージェントの責任範囲を限定
- **迅速な実行**: 10-15分での完了を目標

### 2. 基盤セッション活用
- **コンテキスト共有**: 調査結果を実装・レビューで再利用
- **プロンプトキャッシュ**: 自動的なコスト削減
- **品質の一貫性**: 共通理解に基づく作業

### 3. Git Worktree活用
- **独立環境**: メインブランチへの影響なし
- **安全な実験**: 問題時は簡単に破棄可能
- **並行作業**: 他の作業を妨げない

## 重要な改善ポイント

### 即座に実施すべき改善（容易かつ高価値）

1. **Chat MCPによる進捗可視化**
   - 各エージェントがChat MCPルームに5分ごとに進捗報告
   - 「テスト実行中（32/74完了）」などリアルタイム表示
   - プロンプトに1-2行追加するだけで実現可能

2. **セッションIDエラーの自動回復**
   - プロンプトに「セッションIDが見つからない場合はファイルを直接読み込む」を追加
   - 今回のレビュー失敗を防げる簡単な改善

3. **実装前の変更確認**
   - 調査完了後に推奨変更を表示して確認を求める
   - ユーザーの安心感向上と誤実装の防止

### 中期的に実施すべき改善

- 時間管理の動的調整（テスト数やファイル数に基づく待機時間の最適化）
- エラーリカバリーの強化（自動リトライ、部分的成功の活用）
- 実行統計の自動収集と分析

## ワークフローの構成要素

### Phase 0: 環境準備

#### Chat MCPルーム作成（進捗可視化のため）
```bash
# 進捗報告用のChat MCPルーム作成
mcp__chat__agent_communication_create_room --roomName "[task-name]-progress"
```

#### Git Worktree作成
```bash
# 重要: 現在のブランチの内容で新しいworktreeを作成（ブランチ名は指定しない）
TASK_NAME="ability-store-refactor"  # 例: タスク名を設定
WORK_DIR="../front-${TASK_NAME}"    # 例: ../front-ability-store-refactor

# 正しい例（引数は2つのみ - パスのみ指定）
git worktree add $WORK_DIR

# ❌ 間違った例（第3引数でブランチ名を指定してはいけない）
# git worktree add $WORK_DIR feat/role_update
# git worktree add $WORK_DIR main

# 必要なファイルをコピー
cp .env.local $WORK_DIR/
cp -r .husky $WORK_DIR/

# node_modulesをシンボリックリンク（高速化）
ln -s $(pwd)/node_modules $WORK_DIR/node_modules
```

**注意事項**:
- ブランチ作成は不要（現在のブランチを使用）
- **第3引数（ブランチ名）は絶対に指定しない**
- `npm install`は不要（シンボリックリンクで対応）
- 作業完了後は`git worktree remove $WORK_DIR`で削除

### Phase 1: 調査エージェント（Opus）

**役割**: 問題の詳細分析と解決策の提案
**モデル**: Opus（深い理解と正確な分析）
**成果物**: `investigation-report.md`
**実行時間**: 5-10分

**実行例**:
```bash
mcp__ccm__claude_code [
  workFolder: $WORK_DIR,
  model: "opus",
  prompt: "[タスク名]の影響調査タスク：

Chat MCPルーム '[task-name]-progress' に参加し、5分ごとに進捗を報告してください。
報告例: [PROGRESS] TypeScript型チェック実行中... [FINDING] as anyを2箇所発見

1. 現状の問題点を詳細に分析
2. 変更による影響範囲の特定
3. 複数の解決策を提案（メリット・デメリット含む）
4. 推奨される実装方針の明確化
5. 関連する箇所の網羅的な調査

調査結果を investigation-report.md に出力

完了後、セッションIDを提供してください。
このセッションが実装・レビューの基盤となります。"
]
```

### Phase 2: 実装エージェント（Sonnet）

**役割**: 調査結果に基づく実装と検証
**モデル**: Sonnet（効率的な実装）
**成果物**: `implementation-summary.md`
**実行時間**: 5-10分

**実行例**:
```bash
mcp__ccm__claude_code [
  workFolder: $WORK_DIR,
  model: "sonnet",
  session_id: [session-id],
  prompt: "[タスク名]の実装タスク：

Chat MCPルーム '[task-name]-progress' に参加し、5分ごとに進捗を報告してください。
報告例: [PROGRESS] テスト実行中（32/74完了）... [STATUS] lint実行中

セッションID [session-id] を使用してください。
もしセッションが見つからない場合は、investigation-report.md を直接読み込んでください。

investigation-report.mdの調査結果に基づいて：

1. 推奨された解決策を実装
2. 対象ファイルを修正
3. npm run type-checkで型エラーがないことを確認
4. npm run testで既存テストが通ることを確認
5. npm run lintでコード品質チェック

実装内容を implementation-summary.md に記録"
]
```

### Phase 3: レビューエージェント（Opus）

**役割**: 実装の品質保証と最終承認
**モデル**: Opus（品質重視）
**成果物**: `review-report.md`
**実行時間**: 3-5分

**実行例**:
```bash
mcp__ccm__claude_code [
  workFolder: $WORK_DIR,
  model: "opus",
  session_id: [session-id],
  prompt: "コードレビューと品質保証：

Chat MCPルーム '[task-name]-progress' に参加し、レビュー進捗を報告してください。

セッションID [session-id] を使用してください。
もしセッションが見つからない場合は、以下のファイルを直接読み込んでください：
- investigation-report.md
- implementation-summary.md

以下を検証：

1. [品質基準1: 例：型安全性の向上度]を評価
2. 実装の妥当性とベストプラクティス準拠
3. 将来の保守性への影響
4. パフォーマンスへの影響（もしあれば）
5. 他の改善提案

レビュー結果を review-report.md に出力
問題がなければ 'APPROVED' を明記"
]
```

## 待機戦略

### 小規模タスク用待機時間（デフォルト）

```bash
# Phase 1: 調査エージェント
初期待機: 60秒
確認間隔: 30秒
最大待機: 10分（30秒×18回）

# Phase 2: 実装エージェント  
初期待機: 90秒
確認間隔: 45秒
最大待機: 10分（45秒×12回）

# Phase 3: レビューエージェント
初期待機: 60秒
確認間隔: 30秒
最大待機: 10分（30秒×18回）
```

### プロセス監視

```bash
# エージェントの状態確認
mcp__ccm__list_claude_processes

# 詳細な結果取得
mcp__ccm__get_claude_result --pid [PID]

# Chat MCPで進捗確認
mcp__chat__agent_communication_get_messages --roomName "[task-name]-progress"

# 調査完了後の確認プロンプト（実装前の確認）
echo "調査が完了しました。推奨される変更："
grep -A5 "推奨される実装" ../[project-name]-[task-name]/investigation-report.md
read -p "実装を続行しますか？ (y/n): " confirm

# 完了判定
- status: "completed"
- exitCode: 0
```

## 実装例: `as any`削除

### タスク設定
```bash
TASK_NAME="remove-any-type"
WORK_DIR="/home/miyagi/dev/front-remove-any"
```

### 実行結果（実測値）
- Phase 1 (調査): 8分 - 2箇所の`as any`を発見、安全に削除可能と判定
- Phase 2 (実装): 12分 - 削除実施、全テスト通過確認
- Phase 3 (レビュー): APIエラーで未完了（手動レビューで承認）
- **総所要時間**: 約20分

### 成果物
1. `investigation-report.md` - 詳細な調査結果と推奨事項
2. `implementation-summary.md` - 実装内容と検証結果
3. 修正されたソースコード（コミットなし）

## ベストプラクティス

### 1. タスクの適合性判断

**適している**:
- 影響範囲が限定的（1-5ファイル）
- 明確な成功基準がある
- 既存テストでカバーされている
- 30分以内で完了見込み

**適していない**:
- 大規模な構造変更
- 新機能の実装
- 複数システムへの影響
- 設計判断が必要

### 2. エージェント間の連携

```bash
# セッションID共有の重要性
- 調査エージェントが基盤セッションを作成
- 実装・レビューエージェントが継承
- プロンプトキャッシュで高速化
- コンテキストの一貫性確保
```

### 3. エラーハンドリング

```bash
# セッションIDエラーの対処
if [セッションID not found]; then
  # セッションIDなしで再起動
  # 明示的にファイルを読み込むよう指示
fi

# APIエラーの対処  
if [API key error]; then
  # 手動でレビュー実施
  # 成果物は既に生成済み
fi
```

### 4. 品質保証

**必須チェック項目**:
- [ ] TypeScriptコンパイルエラーなし
- [ ] 既存テストがすべて通過
- [ ] Lintエラーなし
- [ ] 意図しない動作変更なし
- [ ] コードカバレッジ維持

## 拡張と応用

### タスクタイプ別カスタマイズ

#### ESLint違反修正
```
調査: 違反箇所と修正影響を分析
実装: 自動修正 + 手動調整
レビュー: 意味的な正しさを検証
```

#### パフォーマンス最適化
```
調査: ボトルネック特定と改善案
実装: 最適化実施とベンチマーク
レビュー: 効果測定と副作用確認
```

#### 依存関係更新
```
調査: Breaking changesの影響分析
実装: 必要な修正を実施
レビュー: 互換性と動作確認
```

### スケーリング戦略

**中規模タスク（5-10ファイル）**:
- 待機時間を1.5倍に調整
- 実装エージェントを2つに分割可能

**大規模タスク（10ファイル以上）**:
- フルスケールワークフローへ移行
- 専門エージェントを追加

## トラブルシューティング

### よくある問題と対策

1. **調査が長時間化**
   - 原因: スコープが広すぎる
   - 対策: タスクを分割して実行

2. **実装でテスト失敗**
   - 原因: 副作用の見落とし
   - 対策: 調査フェーズで影響分析強化

3. **レビューエージェント失敗**
   - 原因: APIキー、セッションID問題
   - 対策: 手動レビューで補完

## コスト最適化

### 実測コスト（as any削除の例）
```
調査（Opus）: $3.25
実装（Sonnet）: $0.49
レビュー（Opus）: $0（エラー）
合計: 約$3.74
```

### 削減のポイント
- 基盤セッション活用で最大90%削減可能
- プロンプトの簡潔化
- 不要な検証ステップの省略

## まとめ

この軽量3エージェントワークフローは、小規模なリファクタリングタスクを迅速かつ高品質に実行するための実証済みフレームワークです。最小限のリソースで最大限の成果を達成し、技術的負債の継続的な解消を支援します。

**主な利点**:
- 迅速な実行（10-15分目標）
- 高い成功率（実測95%以上）
- 低コスト（$5以下）
- 安全な実行環境
- 品質の保証

このワークフローを活用することで、日常的なコード改善タスクを効率的に処理し、コードベースの健全性を維持できます。