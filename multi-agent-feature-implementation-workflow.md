# 複数エージェントによる新機能実装ワークフロー（TDD版）

## 概要

このドキュメントは、Claude Code MCP（`mcp__ccm__claude_code`）を使用して複数の専門エージェントを協調させ、TDD（Test-Driven Development）の思想に基づいて設計書から効率的に新機能を実装するワークフローを記述します。

**対象読者**: このドキュメントはClaude Codeが参照して、複数エージェントによるTDDベースの新機能実装を実行するためのガイドです。

**前提条件**: 
- 詳細な設計書（`design-document.md`または同等のドキュメント）が存在すること
- 設計書には、機能要件、技術仕様、API仕様、データモデルなどが含まれていること
- TDDのRed-Green-Refactorサイクルを理解していること

## ワークフローの構成要素

### 1. 設計分析エージェント（Design Analysis Agent）
- **役割**: 設計書の分析、テスト仕様の作成、実装計画の策定
- **モデル**: Opus（複雑な設計理解のため）
- **成果物**: `test-specification.md`, `implementation-plan.md`

### 2. テスト作成エージェント（Test Creation Agent）
- **役割**: テスト仕様に基づいた失敗するテストの作成（Red Phase）
- **モデル**: Sonnet（コスト効率を考慮）
- **成果物**: テストコード（失敗する状態）

### 3. 実装エージェント（Implementation Agent）
- **役割**: テストを通すための最小限の実装（Green Phase）
- **モデル**: Sonnet
- **成果物**: 新機能のソースコード（テストが通る状態）

### 4. リファクタリングエージェント（Refactoring Agent）
- **役割**: コードの品質向上とリファクタリング（Refactor Phase）
- **モデル**: Sonnet
- **成果物**: リファクタリングされたコード

### 5. レビューエージェント（Review Agent）
- **役割**: 実装されたコードの品質レビュー
- **モデル**: Opus
- **成果物**: `code-review-report.md`

## 詳細なワークフロー

### Phase 0: 準備とクリーンアップ

ワークフロー開始前に、環境を準備し前回の成果物をクリーンアップします。

```bash
# バックアップディレクトリの作成
mkdir -p ./backup/feature-implementation

# 既存の成果物ファイルを確認
ls -la | grep -E "(test-specification|implementation-plan|test-report|code-review-report)\\.md"

# 既存ファイルがある場合はバックアップ
for file in test-specification.md implementation-plan.md test-report.md code-review-report.md; do
  if [ -f "$file" ]; then
    mv "$file" "./backup/feature-implementation/${file%.md}_$(date +%Y%m%d_%H%M%S).md"
    echo "Backed up $file"
  fi
done

# 設計書の存在確認
if [ ! -f "design-document.md" ]; then
  echo "ERROR: design-document.md not found"
  exit 1
fi
```

### Phase 1: 設計分析とテスト仕様作成

設計分析エージェント（Opus）を起動して、設計書を分析しテスト仕様と実装計画を作成します：

1. **mcp__ccm__claude_code**ツールを使用
2. **model**: "opus"を指定
3. **プロンプトに含める内容**:
   - 設計書（design-document.md）の読み込み指示
   - テスト仕様の作成指示（TDDのためのテストケース設計）
   - 実装計画の作成指示
   - 技術的な課題の洗い出し
   - test-specification.mdとimplementation-plan.mdへの出力指示

**テスト仕様の出力形式**:
```
# テスト仕様
## 機能テストケース
### テストケース1: [名前]
- 前提条件: 
- 入力: 
- 期待結果: 
- テストの種類: unit/integration/e2e

## エッジケーステスト
### エラーケース1: [名前]
- シナリオ:
- 期待される動作:

## パフォーマンステスト
[必要に応じて]
```

**実装計画の出力形式**:
```
# 実装計画
## 機能概要
## 実装スコープ
## TDDサイクル計画
### サイクル1: [最小機能]
- テスト: [対応するテストケース]
- 実装: [最小限の実装内容]
### サイクル2: ...
## 技術スタック
## 依存関係
## リスクと対策
```

### Phase 2: テスト作成（Red Phase）

テスト作成エージェント（Sonnet）を起動して失敗するテストを作成します：

1. **mcp__ccm__claude_code**ツールを使用
2. **model**: "sonnet"を指定
3. **プロンプトに含める内容**:
   - test-specification.mdの読み込み指示
   - implementation-plan.mdの読み込み指示
   - 失敗するテストの作成（実装がまだ存在しないため）
   - テストの実行と失敗の確認
   - テスト結果の報告

**重要**: 
- テストは必ず失敗することを確認（TDDのRed Phase）
- 返されたセッションIDを保存（テスト更新で使用）

### Phase 3: 最小限の実装（Green Phase）

実装エージェント（Sonnet）を起動してテストを通す最小限の実装を行います：

1. **待機時間**: テスト作成完了まで3分待機
2. **mcp__ccm__claude_code**ツールを使用
3. **model**: "sonnet"を指定
4. **プロンプトに含める内容**:
   - 失敗しているテストの確認
   - テストを通すための最小限の実装
   - ハードコーディングも許容（最初のサイクルでは）
   - テストの実行と成功の確認

**重要**: 
- テストが通ることが最優先（コード品質は後で改善）
- 返されたセッションIDを保存（リファクタリングで使用）

### Phase 4: リファクタリング（Refactor Phase）

リファクタリングエージェント（Sonnet）を起動してコード品質を向上させます：

1. **待機時間**: 実装完了まで3分待機
2. **実装エージェントのセッション再開**（Phase 3のセッションIDを使用）
3. **リファクタリング内容**:
   - ハードコーディングの除去
   - 重複コードの削除
   - 適切な抽象化
   - パフォーマンス改善
   - コーディング規約の適用
4. **各リファクタリング後**:
   - テストの再実行
   - 全テストが通ることを確認

### Phase 5: TDDサイクルの繰り返し

実装計画に基づいて、各機能についてPhase 2-4を繰り返します：

1. **次の機能のテスト作成**（Red）
2. **テストを通す実装**（Green）
3. **リファクタリング**（Refactor）

**サイクル管理**:
- implementation-plan.mdのTDDサイクル計画に従う
- 各サイクルで機能を段階的に拡張
- 既存のテストが常に通ることを確認

### Phase 6: 統合テストとコードレビュー

レビューエージェント（Opus）を起動してコードレビューを実施：

1. **待機時間**: 全TDDサイクル完了まで2分待機
2. **mcp__ccm__claude_code**ツールを使用
3. **model**: "opus"を指定
4. **レビュー観点**:
   - 設計書との整合性
   - TDDプロセスの適切性
   - コード品質（可読性、保守性）
   - テストの網羅性
   - パフォーマンス
   - セキュリティ

**レビュー結果の形式**:
```
1行目: APPROVED または NEEDS_IMPROVEMENT
2行目以降: NEEDS_IMPROVEMENTの場合のみ、具体的な指摘事項
```

**重要**: 返されたセッションIDを必ず保存します（再レビューで再利用するため）。

### Phase 7: レビュー指摘修正と再レビューサイクル

1. **2分待機**（レビュー完了を待つ）
2. **code-review-report.md**の1行目を確認
3. **NEEDS_IMPROVEMENT**の場合（最大3回まで繰り返し）:
   
   a. **テスト修正フェーズ**:
      - テスト作成エージェントのセッションを**再開**（Phase 2のセッションIDを使用）
      - レビュー指摘に基づくテストの追加・修正を指示
      - 不足しているエッジケースのカバー
      - 2分待機
   
   b. **実装修正フェーズ**:
      - 実装エージェントのセッションを**再開**（Phase 3のセッションIDを使用）
      - レビュー指摘事項の修正を指示
      - 追加されたテストへの対応
      - 3分待機
   
   c. **再レビューフェーズ**:
      - レビューエージェントのセッションを**再開**（Phase 6のセッションIDを使用）
      - 修正内容の再レビューを指示
      - 2分待機
      - レビュー結果を再確認

**重要**: セッションの再開により、各エージェントは前回のコンテキストを保持したまま作業を継続できます。

### Phase 8: 完了確認

**APPROVED**の場合:
- 新機能実装が完了
- 成果物を確認：
  - test-specification.md（テスト仕様）
  - implementation-plan.md（実装計画）
  - code-review-report.md（レビュー結果）
  - テストコード（全て成功状態）
  - 実装コード（レビュー済み・リファクタリング済み）

**NEEDS_IMPROVEMENT**のまま3回を超えた場合:
- 手動介入が必要であることを報告
- 残存する課題をリスト化

### Phase 9: 最終品質確認

メインエージェントが以下を確認：

1. **成果物の確認**:
   - 全成果物が正しく生成されているか
   - レビューがAPPROVEDであるか

2. **品質チェック**:
   - 全テストが成功
   - テストカバレッジが基準を満たす
   - ビルド成功
   - lintエラーなし
   - 型チェックパス

3. **TDDプロセスの確認**:
   - Red-Green-Refactorサイクルが適切に実行されたか
   - テストファーストが守られたか
   - 段階的な機能拡張が行われたか

## タスク管理のベストプラクティス

TodoWriteツールを使用したTDDベースの進捗管理：

1. **設計分析とテスト仕様の作成**
2. **TDDサイクル1: 最小機能**
   - Red: 失敗するテストを作成
   - Green: テストを通す最小実装
   - Refactor: コード品質向上
3. **TDDサイクル2: 機能拡張**
   - 新しいテストケースの追加
   - 実装の拡張
   - リファクタリング
4. **統合テストの作成と実行**
5. **コードレビューと改善**
6. **最終品質確認**

## エージェント間の連携

### 情報の受け渡し

1. **設計分析 → テスト作成**: test-specification.md
2. **設計分析 → 実装**: implementation-plan.md（TDDサイクル計画）
3. **テスト → 実装**: 失敗するテスト
4. **実装 → リファクタリング**: 成功するテストと実装コード
5. **全サイクル → レビュー**: 完成したコードとテスト
6. **レビュー → 改善**: code-review-report.md

### セッション管理

各エージェントのセッションIDを適切に管理することで、効率的な連携が可能：

1. **設計分析エージェント**: 新規セッション（分析完了後は不要）
2. **テスト作成エージェント**: セッションIDを保持（レビュー修正サイクルで再利用）
3. **実装エージェント**: セッションIDを保持（レビュー修正サイクルで再利用）
4. **レビューエージェント**: セッションIDを保持（再レビューで再利用）

**重要なポイント**:
- mcp__ccm__claude_codeの戻り値からsession_idを取得
- テスト作成、実装、レビューエージェントのセッションIDは変数に保存
- Phase 7でセッションを再開する際は、保存したsession_idを使用
- これにより、各エージェントは前回のコンテキストを保持したまま作業を継続

**TDDサイクルでの活用**:
- 各サイクルでセッションを再開し、継続的に機能を拡張
- テストと実装の対応関係を保持
- リファクタリング時の文脈を維持

## 待機時間の目安

- **設計分析とテスト仕様**: 5分
- **テスト作成（Red）**: 3分
- **最小実装（Green）**: 3-5分
- **リファクタリング（Refactor）**: 3分
- **TDDサイクル**: 1サイクルあたり10-15分
- **レビュー**: 3分（初回）、2分（再レビュー）
- **修正サイクル**: 各フェーズ2-3分

Bashツールの`sleep`コマンドを使用して待機します（例: `sleep 180`は3分待機）。

## 成功パターン

### REST API機能のTDD実装例

1. **設計書**: RESTful APIの仕様（エンドポイント、リクエスト/レスポンス形式）
2. **テスト仕様とTDDサイクル計画**:
   - サイクル1: GETエンドポイントの基本動作
   - サイクル2: POSTエンドポイントとバリデーション
   - サイクル3: エラーハンドリング
   - サイクル4: 認証・認可
3. **TDDサイクル実行**:
   - 各サイクルでRed-Green-Refactorを実施
   - セッションIDを保持して継続的に開発
4. **レビューと修正サイクル**:
   - **初回レビュー**: NEEDS_IMPROVEMENT（セッションID: abc123）
     - エラーハンドリングの改善
     - テストケースの追加
     - パフォーマンス最適化
   - **修正対応**: 
     - テストエージェントのセッション再開（セッションID: test456）
     - 実装エージェントのセッション再開（セッションID: impl789）
   - **再レビュー**: レビューエージェントのセッション再開（abc123）→ APPROVED
5. **最終成果物**:
   - 100%テストカバレッジのAPI
   - レビュー承認済みの高品質コード
   - 段階的に構築された堅牢な実装

## メリット

1. **高品質なコード**: TDDにより設計と品質が向上
2. **早期バグ発見**: テストファーストで問題を早期に発見
3. **リグレッション防止**: 既存機能を壊さない安全な開発
4. **仕様の明確化**: テストが仕様書として機能
5. **段階的開発**: 小さなステップで確実に進捗
6. **高いテストカバレッジ**: 自然に100%に近いカバレッジを達成
7. **リファクタリングの安全性**: テストがセーフティネットとして機能

## 注意事項

1. **テストファースト厳守**: 実装前に必ずテストを書く
2. **小さなステップ**: TDDサイクルは小さく保つ
3. **Red確認の重要性**: テストが失敗することを必ず確認
4. **過度な実装の回避**: テストを通す最小限の実装から始める
5. **継続的リファクタリング**: 各サイクルでコード品質を向上
6. **テストの保守性**: テストコードも本番コードと同じ品質基準で管理
7. **モックとスタブの適切な使用**: 外部依存は適切に分離

## 拡張可能性

- **パフォーマンステストエージェント**: 負荷テストとベンチマーク
- **セキュリティ監査エージェント**: 脆弱性スキャン
- **デプロイメントエージェント**: CI/CDパイプライン統合
- **モニタリング設定エージェント**: ログとメトリクス設定

## 失敗時の対処

- **テストが書けない場合**: 設計の見直しが必要（テスタビリティの問題）
- **テストが通らない場合**: デバッグセッションで原因を特定
- **リファクタリングでテストが壊れた場合**: 変更を巻き戻してやり直し
- **TDDサイクルが大きすぎる場合**: より小さなステップに分割
- **カバレッジが上がらない場合**: 不足しているテストケースを追加

## TDDのベストプラクティス

1. **AAA原則**: Arrange（準備）、Act（実行）、Assert（検証）
2. **1テスト1アサーション**: テストは1つの振る舞いのみを検証
3. **テスト名は仕様**: テスト名で何を検証しているか明確に
4. **F.I.R.S.T原則**: Fast、Independent、Repeatable、Self-validating、Timely
5. **テストのリファクタリング**: DRY原則をテストコードにも適用

このワークフローにより、TDD思想に基づいた高品質な新機能実装を体系的に実施できます。