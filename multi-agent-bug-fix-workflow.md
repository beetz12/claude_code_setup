# 複数エージェントによるバグ修正ワークフロー

## 概要

このドキュメントは、Claude Code MCP（`mcp__ccm__claude_code`）を使用して複数の専門エージェントを協調させ、効率的にバグを修正するワークフローを記述します。

**対象読者**: このドキュメントはClaude Codeが参照して、複数エージェントによるバグ修正を実行するためのガイドです。

## ワークフローの構成要素

### 1. 調査エージェント（Investigation Agent）
- **役割**: バグの原因調査と修正方法の提案
- **モデル**: Ops
- **成果物**: `bug-investigation-report.md`

### 2. 実装エージェント（Implementation Agent）
- **役割**: 調査結果に基づいた修正の実装
- **モデル**: sonnet
- **成果物**: 実際のコード修正

### 3. レビューエージェント（Review Agent）
- **役割**: 実装された修正のコードレビュー
- **モデル**: Opus
- **成果物**: `code-review-report.md`

### 4. デバッグエージェント（Debug Agent）
- **役割**: 問題発生時のトラブルシューティング
- **モデル**: sonnet（コスト効率を重視）
- **起動条件**: エラー発生時や動作確認失敗時のみ起動
- **タスク例**:
  - 環境状態の確認（プロセス状態、ファイルシステム）
  - エラーログの詳細調査
  - 実行環境の問題特定
  - 簡易的な修正提案

## 詳細なワークフロー

### Phase 0: クリーンアップ

ワークフロー開始前に、前回の実行で生成された成果物ファイルをクリーンアップします。

```bash
# バックアップディレクトリの作成（存在しない場合）
mkdir -p ./backup

# 既存の成果物ファイルを確認
ls -la | grep -E "(bug-investigation-report|code-review-report)\.md"

# 既存ファイルがある場合はバックアップ
if [ -f "bug-investigation-report.md" ]; then
  # ./backupディレクトリにタイムスタンプ付きでバックアップ
  mv bug-investigation-report.md "./backup/bug-investigation-report_$(date +%Y%m%d_%H%M%S).md"
  echo "Backed up bug-investigation-report.md"
fi

if [ -f "code-review-report.md" ]; then
  # ./backupディレクトリにタイムスタンプ付きでバックアップ
  mv code-review-report.md "./backup/code-review-report_$(date +%Y%m%d_%H%M%S).md"
  echo "Backed up code-review-report.md"
fi


# 古いバックアップの自動削除（30日以上前のファイル）
# find ./backup -name "*_report_*.md" -mtime +30 -delete
```

### Phase 0.5: 基盤セッション構築

効率的なマルチエージェント実行のため、最初に基盤セッションを構築します：

**基盤セッションの作成**:
```bash
# 1. プロジェクト理解用の基盤セッション作成
mcp__ccm__claude_code [
  model: "sonnet",
  prompt: "プロジェクト構造分析：
  1. CLAUDE.mdを読み込んでプロジェクト概要を理解
  2. package.jsonで技術スタックを確認
  3. 主要ディレクトリ構造を調査
  4. バグ修正に必要な基盤知識を整理
  完了後'BASE_CONTEXT_READY'と報告してセッションIDを提供"
]
```

**基盤セッションの効果**:
- **プロンプトキャッシュ**: CLAUDE.md等の大容量コンテンツが自動キャッシュ
- **コンテキスト共有**: 全エージェントが共通の理解基盤を取得
- **コスト削減**: 後続エージェントで60-90%のトークンコスト削減
- **実行時間短縮**: キャッシュ活用により高速起動

**重要**: 基盤セッションIDを保存（全エージェントで活用）

### Phase 1: バグ調査

調査エージェント（Opus）を**基盤セッションから**起動して、バグの原因を分析します：

1. **mcp__ccm__claude_code**ツールを使用
2. **session_id**: 基盤セッションIDを指定（コンテキスト継承）
3. **model**: "opus"を指定
4. **プロンプトに含める内容**:
   - ユーザーから提供されたバグの詳細
   - 調査手順（コード読み込み、原因特定、影響分析、修正提案）
   - bug-investigation-report.mdへの出力指示

**出力形式の指定**:
```
# バグ調査レポート
## 問題の概要
## 原因の詳細  
## 影響を受けるファイルと関数
## 推奨される修正方法
## 具体的な修正箇所とコード例
```

返されたプロセスIDを保存します（進捗監視用）。

### Phase 2: 進捗監視

1. **5分間待機**（Bashツールで`sleep 300`を実行）
2. **mcp__ccm__get_claude_result**でプロセスの状態を確認
3. 完了していない場合は、さらに**2分待機**して再確認
4. **bug-investigation-report.md**が作成されているか確認（Readツールで確認）

### Phase 3: 修正実装

実装エージェント（Sonnet）を**基盤セッションから**起動して修正を実装します：

1. **mcp__ccm__claude_code**ツールを使用
2. **session_id**: 基盤セッションIDを指定（プロジェクト理解継承）
3. **model**: "sonnet"を指定
4. **プロンプトに含める内容**:
   - bug-investigation-report.mdを読む指示
   - 具体的な修正の実装指示
   - ビルドコマンドの実行指示
   - 実装完了の報告形式

**重要**: 返された**新しいセッションID**を保存します（Claude Codeは自動的に新セッションを生成し、基盤コンテキストを継承）。

### Phase 3.5: 動作確認とデバッグ（オプション）

修正実装後、必要に応じて動作確認を実施します。エラーが発生した場合は、デバッグエージェントを起動：

1. **動作確認の実施**（メインエージェントが実行）
   - 修正された機能の基本的な動作テスト
   - エラーが発生した場合、詳細を記録

2. **デバッグエージェントの起動条件**:
   - 動作確認でエラーが発生
   - ビルドは成功したが実行時エラーが発生
   - 環境に起因する問題が疑われる

3. **デバッグエージェントの起動**（条件に該当する場合のみ）:
   ```
   - model: "sonnet"を指定（コスト効率重視）
   - プロンプト例:
     「以下のエラーが発生しました。環境状態を確認し、原因を特定してください：
     [エラー詳細]
     確認項目：
     - 実行中のプロセス状態
     - 関連ファイルの存在確認
     - ログファイルの内容
     - 簡易的な解決策の提案」
   ```

4. **デバッグ結果の活用**:
   - 環境問題の場合：メインエージェントが対処
   - コード問題の場合：実装エージェントに修正を依頼

### Phase 4: コードレビュー

1. **3分待機**（実装完了を待つ）
2. レビューエージェント（Opus）を**基盤セッションから**起動：
   - **mcp__ccm__claude_code**ツールを使用
   - **session_id**: 基盤セッションIDを指定（プロジェクト理解継承）
   - **model**: "opus"を指定
   - **出力形式を明確に指定**:
     - 1行目: COMPLETED または INCOMPLETE
     - 2行目以降: INCOMPLETEの場合のみ、具体的な指摘事項

**重要**: 返された**新しいセッションID**を保存します（レビューコンテキスト継続用）。

### Phase 5: レビュー指摘修正と再レビューサイクル

1. **2分待機**（レビュー完了を待つ）
2. **code-review-report.md**の1行目を確認
3. **INCOMPLETE**の場合（最大5回まで繰り返し）:
   - 実装エージェントのセッションを**再開**（Phase 3で生成されたセッションIDを使用）
   - 指摘事項の修正を指示
   - 2分待機
   - レビューエージェントのセッションを**再開**（Phase 4で生成されたセッションIDを使用）
   - 再レビューを指示
   - 2分待機
   - レビュー結果を再確認

**重要**: 
- 各エージェントは基盤セッションからコンテキストを継承後、独立セッションで作業継続
- セッション再開時もプロンプトキャッシュ効果が維持され、高速実行が可能
- ファイル競合は自動回避（各エージェントが独立ファイルに書き込み）

### 完了確認

**COMPLETED**の場合:
- バグ修正が完了
- 成果物を確認：
  - bug-investigation-report.md（調査レポート）
  - code-review-report.md（レビュー結果）
  - 修正されたソースコード

**INCOMPLETE**のまま5回を超えた場合:
- 手動介入が必要であることを報告

## タスク管理のベストプラクティス

TodoWriteツールを使用して進捗を管理することを推奨：

1. **バグ調査エージェントの完了確認と調査レポート取得**
2. **実装エージェントによる修正**
3. **修正後の動作確認とテスト**
4. **レビューエージェントによるコードレビュー**
5. **レビュー指摘事項の修正**（必要に応じて）
6. **修正後の再レビュー**（必要に応じて）

各タスクの完了時に状態を更新し、全体の進捗を可視化します。

## エージェント間の連携

### 最適化されたセッション管理戦略

**基盤セッション活用による効率化**:

1. **基盤セッション**: プロジェクト全体の理解を構築（Phase 0.5）
2. **調査エージェント**: 基盤セッションから起動→自動的に新セッション生成
3. **実装エージェント**: 基盤セッションから起動→新セッション生成（修正サイクルで再利用）
4. **レビューエージェント**: 基盤セッションから起動→新セッション生成（再レビューで再利用）

**Claude Codeの実際の動作**:
- `-r <session_id>`で起動時：指定セッションのコンテキストを読み込み
- **自動的に新セッションID生成**：書き込みは新ファイルで競合回避
- **プロンプトキャッシュ継承**：基盤セッションのキャッシュを活用
- **モデル間共有**：Sonnet→Opusでもキャッシュ効果維持

**実証されたコスト削減効果**:
```json
// 基盤セッションからのエージェント起動例
"usage": {
  "input_tokens": 56,                    // 新規入力（微量）
  "cache_creation_input_tokens": 43370,  // キャッシュ作成
  "cache_read_input_tokens": 390302,     // 大量キャッシュ活用
  "output_tokens": 6111
}
// 結果：90%以上のトークンコスト削減
```

**セッション管理のベストプラクティス**:
- 基盤セッションIDの確実な保存と全エージェントでの活用
- 各エージェントの新セッションIDを継続作業用に保存
- セッション複製による安全な並行実行
- プロンプトキャッシュ効果の最大化

## 待機時間の目安

- **調査エージェント**: 5分（初回）、2分（再確認）
- **実装エージェント**: 3分
- **レビューエージェント**: 2分
- **修正サイクル**: 各2分

Bashツールの`sleep`コマンドを使用して待機します（例: `sleep 300`は5分待機）。

## 成功事例

### LockServiceバグ修正の例（最適化版）

**基盤セッション構築**:
- **基盤セッション**: プロジェクト構造とCLAUDE.md読み込み（セッションID: base-001）
- **キャッシュ作成**: 18,621トークンのプロジェクトコンテキスト

**エージェント実行**:
1. **問題**: ロックファイル作成時のディレクトリ不在エラー
2. **調査エージェント**: 基盤セッションから起動→新セッション生成（ID: inv-924fab52）
   - キャッシュ活用: 99,870トークン読み込み、新規入力: 245トークン
   - **調査結果**: `acquireFileLock`メソッドでディレクトリ作成処理が不足
3. **実装エージェント**: 基盤セッションから起動→新セッション生成（ID: impl-e8387697）
   - キャッシュ活用: 324,529トークン読み込み、新規入力: 186トークン
   - **実装**: `fs.mkdir({ recursive: true })`による親ディレクトリ作成
4. **レビューエージェント**: 基盤セッションから起動（Opusモデル）→新セッション生成（ID: rev-a1b2c3d4）
   - **モデル間キャッシュ共有**: 390,302トークン読み込み、新規入力: 56トークン
   - **初回レビュー**: INCOMPLETE（改善提案あり）
5. **修正サイクル**: 各エージェントのセッション再開でコンテキスト継続
6. **再レビュー**: COMPLETED

**効果測定**:
- **総コスト削減**: 約85%（キャッシュ活用による）
- **実行時間短縮**: 約60%（キャッシュによる高速化）
- **品質向上**: モデル間連携による多角的検証

## メリット

1. **専門性の活用**: 各エージェントが特定の役割に集中
2. **品質保証**: 複数の視点からの検証
3. **文書化**: 各フェーズの成果物が自動的に文書化
4. **再現性**: ワークフローが形式化され、再利用可能
5. **並列処理**: 独立したタスクは並行実行可能

## 注意事項

1. **最適化されたコスト管理**: 
   - **基盤セッション活用**: 60-90%のコスト削減効果
   - **プロンプトキャッシュ**: 自動有効化によるトークン削減
   - **モデル選択**: Sonnet（効率）→Opus（品質）の戦略的使い分け
   - **デバッグエージェント**: Sonnetでコスト抑制
2. **セッション管理の実態**:
   - **基盤セッションID**: 全エージェントの起点として確実に保存
   - **自動新セッション生成**: Claude Codeの安全な設計を活用
   - **ファイル競合回避**: 自動的に独立ファイルで書き込み
   - **キャッシュ効果維持**: セッション継承でコスト削減継続
3. **待機時間**: キャッシュ効果による高速化を考慮した時間設定
4. **エラーハンドリング**: 
   - セッション複製失敗時の代替手段
   - キャッシュ効果が得られない場合の対処
   - プロセス管理の改善
5. **クリーンアップ**: 前回の成果物を適切に処理（バックアップまたは削除）
6. **並行実行の活用**:
   - 基盤セッションから複数エージェント同時起動可能
   - 独立性保証によるリスク回避
   - スループット向上効果

## 拡張可能性

このワークフローは以下のような拡張が可能：

- **テストエージェント**: 修正後の自動テスト実行
- **ドキュメントエージェント**: 変更履歴の自動文書化
- **デプロイエージェント**: 修正の自動デプロイ
- **監視エージェント**: 修正後のシステム監視

## エラー処理のポイント

### 基本エラー処理
- **ファイルが見つからない場合**: Readツールのエラーを適切に処理し、報告する
- **タイムアウトの場合**: mcp__ccm__get_claude_resultで状態を確認し、必要に応じて再試行
- **プロセス異常終了の場合**: mcp__ccm__list_claude_processesで状態を確認し、クリーンアップ

### セッション関連エラー処理
- **基盤セッション作成失敗**: 従来の新規セッション方式にフォールバック
- **キャッシュ効果なし**: 実行継続（効率は下がるが機能に影響なし）
- **セッション継承失敗**: 新規セッションで再実行

### パフォーマンス監視
- **usage統計の確認**: cache_read_input_tokensでキャッシュ効果を検証
- **コスト異常時**: 基盤セッション戦略の見直し
- **実行時間監視**: キャッシュ効果による短縮を測定

このワークフローにより、複雑なバグ修正も体系的かつ効率的に実施できます。